Origin: commit, revision id: jelmer@jelmer.uk-20190211194051-p6mcy0l590qm022m
Author: Jelmer VernooÄ³ <jelmer@jelmer.uk>
Last-Update: 2019-02-11
Applied-Upstream: no
X-Bzr-Revision-Id: jelmer@jelmer.uk-20190211194051-p6mcy0l590qm022m

=== modified file 'breezy/git/mapping.py'
--- old/breezy/git/mapping.py	2019-01-13 18:59:26 +0000
+++ new/breezy/git/mapping.py	2019-02-11 19:40:51 +0000
@@ -37,6 +37,7 @@
     )
 from ..revision import (
     NULL_REVISION,
+    Revision,
     )
 from ..sixish import (
     PY3,
@@ -377,6 +378,17 @@
         """
         return deserialize_fileid_map(blob.data)
 
+    def get_revision_id(self, commit):
+        if commit.encoding:
+            encoding = commit.encoding.decode('ascii')
+        else:
+            encoding = 'utf-8'
+        message, metadata = self._decode_commit_message(
+            None, commit.message, encoding)
+        if metadata.revision_id:
+            return metadata.revision_id
+        return self.revision_id_foreign_to_bzr(commit.id)
+
     def import_commit(self, commit, lookup_parent_revid):
         """Convert a git commit to a bzr revision.
 
@@ -499,6 +511,8 @@
     BZR_DUMMY_FILE = '.bzrdummy'
 
     def _decode_commit_message(self, rev, message, encoding):
+        if rev is None:
+            rev = Revision()
         message = self._extract_hg_metadata(rev, message)
         message = self._extract_git_svn_metadata(rev, message)
         message, metadata = self._extract_bzr_metadata(rev, message)

=== modified file 'breezy/git/repository.py'
--- old/breezy/git/repository.py	2018-11-30 12:39:04 +0000
+++ new/breezy/git/repository.py	2019-02-11 19:40:51 +0000
@@ -348,9 +348,9 @@
             o = self._git.object_store[sha]
             if not isinstance(o, Commit):
                 continue
-            rev, roundtrip_revid, verifiers = mapping.import_commit(
-                o, mapping.revision_id_foreign_to_bzr)
-            yield o.id, rev.revision_id, roundtrip_revid
+            revid = mapping.revision_id_foreign_to_bzr(o)
+            roundtrip_revid = mapping.get_revision_id(o)
+            yield o.id, revid, (roundtrip_revid if revid != roundtrip_revid else None)
 
     def all_revision_ids(self):
         ret = set()
@@ -454,13 +454,9 @@
         commit = self._git.object_store.peel_sha(foreign_revid)
         if not isinstance(commit, Commit):
             raise NotCommitError(commit.id)
-        rev, roundtrip_revid, verifiers = mapping.import_commit(
-            commit, mapping.revision_id_foreign_to_bzr)
+        revid = mapping.get_revision_id(commit)
         # FIXME: check testament before doing this?
-        if roundtrip_revid:
-            return roundtrip_revid
-        else:
-            return rev.revision_id
+        return revid
 
     def has_signature_for_revision_id(self, revision_id):
         """Check whether a GPG signature is present for this revision.

=== modified file 'breezy/git/tests/test_blackbox.py'
--- old/breezy/git/tests/test_blackbox.py	2019-01-02 18:49:15 +0000
+++ new/breezy/git/tests/test_blackbox.py	2019-02-06 05:44:37 +0000
@@ -308,6 +308,7 @@
         self.repo.stage("foo")
         self.repo.do_commit(
             b"message", committer=b"Somebody <user@example.com>",
+            author=b"Somebody <user@example.com>",
             commit_timestamp=1526330165, commit_timezone=0,
             author_timestamp=1526330165, author_timezone=0,
             merge_heads=[b'aa' * 20])

=== modified file 'breezy/git/tests/test_mapping.py'
--- old/breezy/git/tests/test_mapping.py	2019-01-13 14:16:35 +0000
+++ new/breezy/git/tests/test_mapping.py	2019-02-11 19:40:51 +0000
@@ -235,6 +235,9 @@
         self.assertRaises(
             UnknownMercurialCommitExtra,
             mapping.import_commit, c, mapping.revision_id_foreign_to_bzr)
+        self.assertEqual(
+            mapping.revision_id_foreign_to_bzr(c.id),
+            mapping.get_revision_id(c))
 
 
 class RoundtripRevisionsFromBazaar(tests.TestCase):

=== modified file 'breezy/git/transportgit.py'
--- old/breezy/git/transportgit.py	2018-11-11 14:23:06 +0000
+++ new/breezy/git/transportgit.py	2019-02-06 05:44:37 +0000
@@ -36,6 +36,7 @@
 from dulwich.object_store import (
     PackBasedObjectStore,
     PACKDIR,
+    read_packs_file,
     )
 from dulwich.pack import (
     MemoryPackIndex,
@@ -587,16 +588,41 @@
                 ret.append(l)
             return ret
 
-    @property
-    def packs(self):
-        # FIXME: Never invalidates.
-        if not self._pack_cache:
-            self._update_pack_cache()
-        return self._pack_cache.values()
-
     def _update_pack_cache(self):
-        for pack in self._load_packs():
-            self._pack_cache[pack._basename] = pack
+        pack_files = set()
+        pack_dir_contents = self._pack_names()
+        for name in pack_dir_contents:
+            if name.startswith("pack-") and name.endswith(".pack"):
+                # verify that idx exists first (otherwise the pack was not yet
+                # fully written)
+                idx_name = os.path.splitext(name)[0] + ".idx"
+                if idx_name in pack_dir_contents:
+                    pack_files.add(os.path.splitext(name)[0])
+
+        new_packs = []
+        for basename in pack_files:
+            pack_name = basename + ".pack"
+            if basename not in self._pack_cache:
+                try:
+                    size = self.pack_transport.stat(pack_name).st_size
+                except TransportNotPossible:
+                    f = self.pack_transport.get(pack_name)
+                    pd = PackData(pack_name, f)
+                else:
+                    pd = PackData(
+                        pack_name, self.pack_transport.get(pack_name),
+                        size=size)
+                idxname = basename + ".idx"
+                idx = load_pack_index_file(
+                    idxname, self.pack_transport.get(idxname))
+                pack = Pack.from_objects(pd, idx)
+                pack._basename = basename
+                self._pack_cache[basename] = pack
+                new_packs.append(pack)
+        # Remove disappeared pack files
+        for f in set(self._pack_cache) - pack_files:
+            self._pack_cache.pop(f).close()
+        return new_packs
 
     def _pack_names(self):
         try:
@@ -608,9 +634,6 @@
                 # Hmm, warn about running 'git update-server-info' ?
                 return iter([])
             else:
-                # TODO(jelmer): Move to top-level after dulwich
-                # 0.19.7 is released.
-                from dulwich.object_store import read_packs_file
                 with f:
                     return read_packs_file(f)
         except NoSuchFile:
@@ -619,26 +642,10 @@
     def _remove_pack(self, pack):
         self.pack_transport.delete(os.path.basename(pack.index.path))
         self.pack_transport.delete(pack.data.filename)
-
-    def _load_packs(self):
-        ret = []
-        for name in self._pack_names():
-            if name.startswith("pack-") and name.endswith(".pack"):
-                try:
-                    size = self.pack_transport.stat(name).st_size
-                except TransportNotPossible:
-                    f = self.pack_transport.get(name)
-                    pd = PackData(name, f)
-                else:
-                    pd = PackData(name, self.pack_transport.get(name),
-                                  size=size)
-                idxname = name.replace(".pack", ".idx")
-                idx = load_pack_index_file(
-                    idxname, self.pack_transport.get(idxname))
-                pack = Pack.from_objects(pd, idx)
-                pack._basename = idxname[:-4]
-                ret.append(pack)
-        return ret
+        try:
+            del self._pack_cache[os.path.basename(pack._basename)]
+        except KeyError:
+            pass
 
     def _iter_loose_objects(self):
         for base in self.transport.list_dir('.'):
@@ -702,7 +709,7 @@
         idx = load_pack_index_file(basename + ".idx", idxfile)
         final_pack = Pack.from_objects(p, idx)
         final_pack._basename = basename
-        self._add_known_pack(basename, final_pack)
+        self._add_cached_pack(basename, final_pack)
         return final_pack
 
     def move_in_thin_pack(self, f):
@@ -735,8 +742,6 @@
             write_pack_index_v2(idxfile, entries, data_sum)
         finally:
             idxfile.close()
-        # TODO(jelmer): Just add new pack to the cache
-        self._flush_pack_cache()
 
     def add_pack(self):
         """Add a new pack to this object store.

=== modified file 'setup.py'
--- old/setup.py	2019-01-24 00:23:01 +0000
+++ new/setup.py	2019-02-06 05:44:37 +0000
@@ -60,7 +60,7 @@
         # Technically, Breezy works without these two dependencies too. But there's
         # no way to enable them by default and let users opt out.
         'fastimport>=0.9.8',
-        'dulwich>=0.19.1',
+        'dulwich>=0.19.11',
         ],
     'extras_require': {
         'fastimport': [],

